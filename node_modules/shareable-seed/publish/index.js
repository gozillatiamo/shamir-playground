'use strict';

var bip39 = require('bip39');
var _ = require('lodash');
var zeroFill = require('zero-fill');
var shajs = require('sha.js');
var secrets = require('secrets.js-grempe');
var validators = require('./lib/validators');
var wordlistCodes = require('./lib/wordlistCodes');
var versionCodes = require('./lib/versionCodes');
var util = require('./lib/util');
var extractors = require('./lib/extractors');
var errors = require('./lib/errors');

var ENTROPY_LENGTH_PADDED_HEX = 2;
var ENTROPY_PADDED_LENGTH = 64;
var CHECKSUM_HEX_LENGTH = 8;

function wordlistCodeToWordlist(wordlistCode) {
  validators.validateWordlistCode(wordlistCode);
  var wordlistName = _.find(wordlistCodes, function (v, k) {
    return v === wordlistCode;
  });
  return _.get(bip39.wordlists, wordlistName);
}

function mnemonicToEntropy(mnemonic, wordlistName) {
  validators.validateWordlistName(wordlistName);
  var wordlist = _.get(bip39.wordlists, wordlistName);
  if (!wordlist) throw new Error(errors.INVALID_WORDLIST_NAME);
  return bip39.mnemonicToEntropy(mnemonic, wordlist);
}

function mnemonicToShareableCode(mnemonic, versionName, wordlistName) {
  validators.validateMnemonic(mnemonic);
  validators.validateVersionName(versionName);
  validators.validateWordlistName(wordlistName);
  var wordlistCode = _.get(wordlistCodes, wordlistName);
  var entropyHex = mnemonicToEntropy(mnemonic, wordlistName);
  var paddedEntropyHex = zeroFill(ENTROPY_PADDED_LENGTH, entropyHex);
  var entropyLenghHex = util.numberToHexCode(entropyHex.length, ENTROPY_LENGTH_PADDED_HEX, true);
  var versionCode = _.get(versionCodes, versionName, '00');
  var rawShareableCode = versionCode + wordlistCode + entropyLenghHex + paddedEntropyHex;
  var checksum = shajs('sha256').update(rawShareableCode).digest('hex').slice(0, CHECKSUM_HEX_LENGTH);
  return rawShareableCode + checksum;
}

function mnemonicToShares(mnemonic, shareCount, threshold, versionName, wordlistName) {
  validators.validateMnemonic(mnemonic);
  validators.validateVersionName(versionName);
  validators.validateWordlistName(wordlistName);
  validators.validateShareCount(shareCount);
  validators.validateThreshold(threshold);
  var shareableCode = mnemonicToShareableCode(mnemonic, versionName, wordlistName);
  var rawShares = secrets.share(shareableCode, shareCount, threshold, 0);
  var shareIDToShare = {};
  for (var i = 0; i < rawShares.length; i++) {
    var rawShare = rawShares[i];

    var _secrets$extractShare = secrets.extractShareComponents(rawShare),
        id = _secrets$extractShare.id;

    shareIDToShare[id] = rawShare;
  }
  return shareIDToShare;
}

function shareListToMnemonic(shareList) {
  validators.validateShareList(shareList);
  var potentialShareableCode = secrets.combine(shareList);
  var mnemonic = '';
  try {
    mnemonic = shareableCodeToMnemonic(potentialShareableCode);
  } catch (err) {
    return null;
  }
  return mnemonic;
}

function shareableCodeToMnemonic(shareableCode) {
  validators.validateShareableCodeChecksum(shareableCode);
  var entropyHex = extractors.extractEntropyHex(shareableCode);
  var wordlistCode = extractors.extractWordlistCode(shareableCode);
  var wordlist = wordlistCodeToWordlist(wordlistCode);
  return bip39.entropyToMnemonic(entropyHex, wordlist);
}

module.exports = {
  mnemonicToShareableCode: mnemonicToShareableCode,
  mnemonicToShares: mnemonicToShares,
  shareableCodeToMnemonic: shareableCodeToMnemonic,
  shareListToMnemonic: shareListToMnemonic
};